"use strict";
///<reference path="../../node_modules/@types/node/index.d.ts"/>
Object.defineProperty(exports, "__esModule", { value: true });
var Command_1 = require("./Command");
var CommandList_1 = require("./CommandList");
var Error_1 = require("./Error");
var Util_1 = require("./Util");
var ResponseParser = (function () {
    /**
     * Creates new response parser.
     *
     * @param {string} response - Response from MPD server.
     * @param {*} command - Command or CommandList.
     */
    function ResponseParser(response, command) {
        this.response = response;
        this.command = command;
    }
    /**
     * The only one public method which is also an entrypoint.
     *
     * @param {*} resolve
     *   Callable or null. See ES6-Promise for details.
     * @param {*} reject
     *   Callable or null. See ES6-Promise for details.
     *
     * @returns {Array}
     *   Array of object (case when we parse single command from CommandList).
     */
    ResponseParser.prototype.parse = function (resolve, reject) {
        if (resolve === void 0) { resolve = null; }
        if (reject === void 0) { reject = null; }
        var errorInfo = ResponseParser.RESPONSE_PARSER_ERROR_PATTERN.exec(this.response);
        if (errorInfo) {
            reject(new Error_1.Error(errorInfo));
        }
        this.response = this.response.replace(/^OK$/gm, '').trim();
        return this.command instanceof Command_1.MPDCommand ? this.processCommand(resolve) : this.processCommandList(resolve);
    };
    /**
     * Process response for single command or command from CommandList.
     *
     * This command applies for parsing response for single Command
     * or command from CommandList with command_list_ok_begin mode.
     *
     * @param {*} resolve - Resolve callback or null. If null passed then it means that we parses command from CL.
     *
     * @returns {*[]|void} - Array of built objects/resolves promise.
     */
    ResponseParser.prototype.processCommand = function (resolve) {
        if (resolve === void 0) { resolve = null; }
        var cmd = this.command.getCommand();
        var delimiters = this.getCommandDelimiters()[cmd] || [];
        var processedDelimiters = delimiters.reduce(function (prev, current) {
            prev[current] = null;
            return prev;
        }, {});
        var result = this.parseResponse(processedDelimiters);
        if (resolve) {
            resolve({ response: result, type: 'command' });
        }
        else {
            return result;
        }
    };
    /**
     * Process response for command list.
     *
     * @param {function} resolve - Resolve callback.
     */
    ResponseParser.prototype.processCommandList = function (resolve) {
        var _this = this;
        var result;
        var commands = this.command.getCommands();
        // This case is pretty simple: just split response by delimiter and
        // parse separated response in mapping with set of commands.
        if (this.command.getMode() === CommandList_1.MPDCommandList.COMMAND_LIST_OK_BEGIN) {
            result = this.response
                .split(CommandList_1.MPDCommandList.COMMAND_LIST_OK_SEPARATOR)
                .filter(function (item) { return item; })
                .map(function (item) { return item.trim(); })
                .reduce(function (prev, current, index) {
                var cmd = commands[index];
                prev.push({ response: new ResponseParser(current, cmd), command: cmd.getCommand() });
                return prev;
            }, []);
        }
        else {
            var commandDelimiters = commands.reduce(function (prev, cmd) {
                var command = cmd.getCommand();
                // Collect delimiters for each command from set of commands.
                // This will allow us parse response correct.
                if (typeof prev[command] === 'undefined') {
                    prev[command] = _this.getCommandDelimiters()[command] || {};
                }
                return prev;
            }, {});
            result = this.parseResponse(commandDelimiters);
        }
        resolve({ response: result, type: 'commandList' });
    };
    /**
     * Get command delimiters.
     *
     * There are can be some commands (such as lsinfo or plalistinfo)
     * which returns collection of same objects as result. Also there
     * are exists command lists with standard execution mode (returns
     * single-row output).
     * So we need set of uniq keys for each command.
     *
     * @returns {object} - Delimiters merged into united array.
     *
     * @todo: Check other commands output.
     * @todo: Maybe it should be generated when server started for reducing first request handle time.
     */
    ResponseParser.prototype.getCommandDelimiters = function () {
        var data = global['mpdCommandDelimiters'] || {};
        if (Util_1.objIsEmpty(data)) {
            [
                { commands: ['lsinfo', 'listall', 'listallinfo'], delimiters: ['file', 'directory', 'playlist'] },
                { commands: ['listfiles'], delimiters: ['file', 'directory'] },
                { commands: ['update', 'rescan'], delimiters: ['updating_db'] },
                { commands: ['commands', 'notcommands'], delimiters: ['command'] },
                { commands: ['listplaylists'], delimiters: ['playlist'] },
                { commands: ['currentsong', 'playlistinfo', 'listplaylist', 'listplaylistinfo', 'playlistid'], delimiters: ['file'] },
                { commands: ['idle'], delimiters: ['changed'] },
                { commands: ['tagtype'], delimiters: ['tagtype'] },
                { commands: ['decoders'], delimiters: ['plugin'] },
                { commands: ['status'], delimiters: ['volume'] },
                { commands: ['stats'], delimiters: ['uptime'] },
            ].forEach(function (value) {
                value['commands'].forEach(function (v) { return data[v] = value['delimiters']; });
            });
            global['mpdCommandDelimiters'] = data;
        }
        return data;
    };
    /**
     * Parse response and return array of objects.
     *
     * @param {object} commandDelimiters - delimiters merged to united object.
     *
     * @returns {object[]} - Array of objects.
     *
     * @see getCommandDelimiters().
     */
    ResponseParser.prototype.parseResponse = function (commandDelimiters) {
        var result = [], obj = {};
        this.response
            .split('\n')
            .forEach(function (val) {
            var _a = val.split(': '), key = _a[0], value = _a[1];
            var currentRowIsDelimiter = typeof commandDelimiters[key] !== 'undefined';
            // If this row is delimiter then we need finalize our object and reset obj.
            if (currentRowIsDelimiter && !Util_1.objIsEmpty(obj)) {
                result.push(obj);
                obj = {};
            }
            // This allow us build correct response for structure with multiple keys
            // related to one object. See response of decoders command for example.
            if (key) {
                if (typeof obj[key] !== 'undefined') {
                    if (Array.isArray(obj[key])) {
                        obj[key].push(value);
                    }
                    else {
                        obj[key] = [obj[key], value];
                    }
                }
                else {
                    obj[key] = value;
                }
            }
        });
        // Don't forget about last iteration. But we don't need to store empty object.
        if (!Util_1.objIsEmpty(obj)) {
            result.push(obj);
        }
        return result;
    };
    return ResponseParser;
}());
/**
 * Pattern to check if error exists and collect info about it.
 *
 * @type {RegExp}
 */
ResponseParser.RESPONSE_PARSER_ERROR_PATTERN = /^ACK\s\[(\d+)@([^\]]+)\]\s\{([^\}]*)\}\s(.+)$/gm;
exports.ResponseParser = ResponseParser;
